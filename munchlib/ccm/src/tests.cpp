//
// Created by Isura Manchanayaka on 20/2/2024.
//

#include "tests.h"
#include "embed.h"
#include "knn.h"
#include "ccm.h"
#include "utils.h"
#include "interface.h"

#include <iostream>
#include <span>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <string>


void test_embeds() {
    std::cout << "\033[1;32m";
    std::cout << "[" << __FUNCTION__  << "]\n";
    std::cout << "\033[0m";
    std::vector<double> v{1, 2, 3, 4, 5, 6, 7, 8};
    const auto features = embed<3>(1, v);
    for(size_t i = 0; i < features.size(); ++i) {
        std::cout << i << ": ";
        for(double e : features[i]) {
            std::cout << e << ' ';
        }
        std::cout << '\n';
    }
}

void test_pearson() {
    std::cout << "\033[1;32m";
    std::cout << "[" << __FUNCTION__  << "]\n";
    std::cout << "\033[0m";
    std::vector<double> v1{1, 2, 3, 4, 5, 6, 7, 8};
    std::vector<double> v2{8, 7, 6, 5, 4, 3, 2, 1};
    std::cout << pearson(v1, v2) << " = -1" << '\n';
    std::cout << pearson(v1, v1) << " =  1" << '\n';
    std::vector<double> v3{0.5488135039273248, 0.7151893663724195, 0.6027633760716439, 0.5448831829968969, 0.4236547993389047, 0.6458941130666561, 0.4375872112626925, 0.8917730007820798, 0.9636627605010293, 0.3834415188257777};
    std::vector<double> v4{0.7917250380826646, 0.5288949197529045, 0.5680445610939323, 0.925596638292661, 0.07103605819788694, 0.08712929970154071, 0.02021839744032572, 0.832619845547938, 0.7781567509498505, 0.8700121482468192};
    std::cout << std::setprecision(20) << pearson(v3, v4) << " = 0.33496904905220537" << '\n';
}

void test_exp_weights() {
    std::cout << "\033[1;32m";
    std::cout << "[" << __FUNCTION__  << "]\n";
    std::cout << "\033[0m";
    std::vector<std::vector<double>> X{
            {1, 2, 3, 4, 5},
            {5, 4, 3, 2, 1},
            {1, 2, 3, 4, 5},
            {5, 4, 3, 2, 1},
            {1, 2, 3, 4, 5},
    };
    auto W = exp_weights(X);
    for(const auto &w: W) {
        for(double e: w) {
            std::cout << e << ' ';
        }
        std::cout << '\n';
    }
    std::cout << "= [[0.63640516 0.23412272 0.08612979 0.0316857  0.01165663]\n"
                 " [0.12885137 0.15737936 0.1922235  0.23478222 0.28676354]\n"
                 " [0.63640516 0.23412272 0.08612979 0.0316857  0.01165663]\n"
                 " [0.12885137 0.15737936 0.1922235  0.23478222 0.28676354]\n"
                 " [0.63640516 0.23412272 0.08612979 0.0316857  0.01165663]]\n";
    std::cout << "------\n";
    std::vector<std::vector<double>> Y{{0.7252542798196405, 0.5013243819267023, 0.9560836347232239, 0.6439901992296374, 0.4238550485581797}
            , {0.6063932141279244, 0.019193198309333526, 0.30157481667454933, 0.660173537492685, 0.29007760721044407}
            , {0.6180154289988415, 0.42876870094576613, 0.13547406422245023, 0.29828232595603077, 0.5699649107012649}
            , {0.5908727612481732, 0.5743252488495788, 0.6532008198571336, 0.6521032700016889, 0.43141843543397396}
            , {0.896546595851063, 0.36756187004789653, 0.4358649252656268, 0.8919233550156721, 0.8061939890460857}
    };
    W = exp_weights(Y);
    for(const auto &w: W) {
        for(double e: w) {
            std::cout << e << ' ';
        }
        std::cout << '\n';
    }
    std::cout << "= [[0.17473537 0.23794247 0.12710371 0.19545305 0.26476542]\n"
                 " [0.12679785 0.33392845 0.20961244 0.11603672 0.21362454]\n"
                 " [0.13698887 0.18606788 0.29907035 0.22980839 0.14806452]\n"
                 " [0.19456648 0.20009228 0.17508839 0.17541392 0.25483893]\n"
                 " [0.15181624 0.27387973 0.25378953 0.15260113 0.16791337]]\n";
}

void test_knn() {
    std::cout << "\033[1;32m";
    std::cout << "[" << __FUNCTION__  << "]\n";
    std::cout << "\033[0m";
    std::vector<std::array<double, 3>> X{{0.039187792254320675, 0.2828069625764096, 0.1201965612131689}
            , {0.29614019752214493, 0.11872771895424405, 0.317983179393976}
            , {0.41426299451466997, 0.06414749634878436, 0.6924721193700198}
            , {0.5666014542065752, 0.2653894909394454, 0.5232480534666997}
            , {0.09394051075844168, 0.5759464955561793, 0.9292961975762141}
            , {0.31856895245132366, 0.6674103799636817, 0.13179786240439217}
            , {0.7163272041185655, 0.2894060929472011, 0.18319136200711683}
            , {0.5865129348100832, 0.020107546187493552, 0.8289400292173631}
            , {0.004695476192547066, 0.6778165367962301, 0.27000797319216485}
            , {0.7351940221225949, 0.9621885451174382, 0.24875314351995803}
    };
    std::vector<std::array<double, 3>> X_test{{0.5761573344178369, 0.592041931271839, 0.5722519057908734}
            , {0.2230816326406183, 0.952749011516985, 0.44712537861762736}
            , {0.8464086724711278, 0.6994792753175043, 0.29743695085513366}
            , {0.8137978197024772, 0.39650574084698464, 0.8811031971111616}
            , {0.5812728726358587, 0.8817353618548528, 0.6925315900777659}
    };
    KNN<3> knn(3, X.cbegin(), X.cend());
    auto [distances, indices] = knn.k_neighbors(X_test);
    std::cout << "Distances:\n";
    for(const auto &d: distances) {
        for(double e: d) {
            std::cout << e << ' ';
        }
        std::cout << '\n';
    }
    std::cout << "= array([[0.33044592, 0.51244917, 0.51578284],\n"
                 "        [0.39325686, 0.4358525 , 0.54927202],\n"
                 "        [0.28940451, 0.44512162, 0.55414754],\n"
                 "        [0.442781  , 0.45426624, 0.5528759 ],\n"
                 "        [0.47655403, 0.62213917, 0.63933903]])\n";
    std::cout << "Indices:\n";
    for(const auto &i: indices) {
        for(size_t e: i) {
            std::cout << e << ' ';
        }
        std::cout << '\n';
    }
    std::cout << "= array([[3, 6, 5],\n"
                 "        [8, 5, 9],\n"
                 "        [9, 6, 5],\n"
                 "        [7, 3, 2],\n"
                 "        [9, 4, 3]])\n";
}

void test_ccm() {
    std::cout << "\033[1;32m";
    std::cout << "[" << __FUNCTION__  << "]\n";
    std::cout << "\033[0m";
    std::vector<std::array<double, 3>> X1_train{{0.3117958819941026, 0.6963434888154595, 0.3777518392924809}
            , {0.1796036775596348, 0.02467872839133123, 0.06724963146324858}
            , {0.6793927734985673, 0.4536968445560453, 0.5365792111087222}
            , {0.8966712930403421, 0.9903389473967044, 0.21689698439847394}
            , {0.6630782031001008, 0.26332237673715064, 0.02065099946572868}
            , {0.7583786538361414, 0.32001715082246784, 0.38346389417189797}
            , {0.5883171135536057, 0.8310484552361904, 0.6289818435911487}
            , {0.8726506554473953, 0.27354203481563577, 0.7980468339125637}
            , {0.1856359443059522, 0.9527916569719446, 0.6874882763878153}
            , {0.21550767711355845, 0.9473705904889242, 0.7308558067701578}
    };
    std::vector<std::array<double, 3>> X2_train{{0.3117958819941026, 0.6963434888154595, 0.3777518392924809}
            , {0.1796036775596348, 0.02467872839133123, 0.06724963146324858}
            , {0.6793927734985673, 0.4536968445560453, 0.5365792111087222}
            , {0.8966712930403421, 0.9903389473967044, 0.21689698439847394}
            , {0.6630782031001008, 0.26332237673715064, 0.02065099946572868}
            , {0.7583786538361414, 0.32001715082246784, 0.38346389417189797}
            , {0.5883171135536057, 0.8310484552361904, 0.6289818435911487}
            , {0.8726506554473953, 0.27354203481563577, 0.7980468339125637}
            , {0.1856359443059522, 0.9527916569719446, 0.6874882763878153}
            , {0.21550767711355845, 0.9473705904889242, 0.7308558067701578}
    };
    std::vector<std::array<double, 3>> X1_test{{0.25394164259502583, 0.21331197736748198, 0.5182007139306632}
            , {0.025662718054531575, 0.2074700754411094, 0.42468546875150626}
            , {0.37416998033422555, 0.4635754243648107, 0.2776287062947319}
            , {0.5867843464581688, 0.8638556059232314, 0.11753185596203308}
            , {0.5173791071541142, 0.1320681063451533, 0.7168596811925937}
    };
    std::vector<std::array<double, 3>> X2_test{{0.25394164259502583, 0.21331197736748198, 0.5182007139306632}
            , {0.025662718054531575, 0.2074700754411094, 0.42468546875150626}
            , {0.37416998033422555, 0.4635754243648107, 0.2776287062947319}
            , {0.5867843464581688, 0.8638556059232314, 0.11753185596203308}
            , {0.5173791071541142, 0.1320681063451533, 0.7168596811925937}
    };
    CCM<3> ccm(X1_train, X2_train, X1_test, X2_test);
    ccm.predict({5, 6});
    auto [scores_1, scores_2] = ccm.score();
    for(double e: scores_1) {
        std::cout << e << ' ';
    }
    std::cout << '\n';
    for(double e: scores_2) {
        std::cout << e << ' ';
    }
    std::cout << '\n';
}

void test_cpp_ccm_coordination(const std::string &x1_path, const std::string &x2_path) {
    std::cout << "\033[1;32m";
    std::cout << "[" << __FUNCTION__  << "]\n";
    std::cout << "\033[0m";
//    auto [sc1, sc2] = cpp_ccm_coordination(
//        {1, 2, 3, 4, 5, 6, 7, 8, 9},
//        {5, 4, 3, 2, 1, 6, 7, 8, 9},
//        3, 1, {5, 6}
//    );
//    for(double e: sc1) {
//        std::cout << e << ' ';
//    }
//    std::cout << '\n';
//    for(double e: sc2) {
//        std::cout << e << ' ';
//    }
//    std::cout << '\n';
    std::ifstream x1_file(x1_path);
    std::ifstream x2_file(x2_path);
    std::vector<double> x1;
    std::vector<double> x2;
    std::string line;
    while(std::getline(x1_file, line)) {
        std::istringstream iss(line);
        double val;
        iss >> val;
        x1.push_back(val);
//        if(x1.size() == 1000) {
//            break;
//        }
    }
    while(std::getline(x2_file, line)) {
        std::istringstream iss(line);
        double val;
        iss >> val;
        x2.push_back(val);
//        if(x2.size() == 1000) {
//            break;
//        }
    }
    std::vector<uint64_t> lib_lens;
    const size_t n_elems = 50;
    const size_t embed_size = 10;
    for(size_t i = (embed_size + 1) * n_elems, s = (x1.size() / 4 + 1) * n_elems, inc = x1.size() / 4 - embed_size; i < s; i += inc) {
        lib_lens.push_back(i / n_elems);
    }
    const auto &begin = std::chrono::steady_clock::now();
    auto [sc1, sc2] = cpp_ccm_coordination(x1, x2, 10, 1, lib_lens);
    const auto &end = std::chrono::steady_clock::now();
    std::cout << "Time elapsed = " << (std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() / 1000) << " ms\n";
    std::cout << sc1.size() << ' ' << sc2.size() << '\n';
}